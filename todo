#!/usr/bin/env python

# dependencies
# python2
# xsel

import fcntl
import os
import os.path
import readline
import signal
import sys

HOME_DIR = os.path.expanduser('~')
TODO_FILE = HOME_DIR + '/.todo'
PID_FILE = HOME_DIR + '/todo.pid'
PID_FILE_DESCRIPTOR = open(PID_FILE, 'r+')

def acquire_lock():
    try:
        fcntl.lockf(PID_FILE_DESCRIPTOR, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError as err:
        print >> sys.stderr, 'error: another instance of this program is already running'
        exit(1)

def release_lock():
    fcntl.lockf(PID_FILE_DESCRIPTOR, fcntl.LOCK_UN)

def input_with_prefill(prompt, text):
    def hook():
        readline.insert_text(text)
        readline.redisplay()
    readline.set_pre_input_hook(hook)
    try:
        result = raw_input(prompt)
    except EOFError:
        return None
    finally:
        readline.set_pre_input_hook()
    return result

def pop_readline_history():
    current_history_length = readline.get_current_history_length()
    readline.remove_history_item(current_history_length - 1)

def show_help():
    print '''    + <String> - Add a TODO entry
    - <Int> - Delete the entry
    e <Int> - Edit an entry
    c <Int> - Add an entry to the clipboard
    ?, h - Show help
    q - Quit'''

def show_todo():
    print '\n------------------------------\n'
    print 'Current TODO list\n'
    for idx, item in enumerate(todo):
        print idx, item

def save_to_disk():
    global todo
    print 'Saving to disk...',
    with open(TODO_FILE, 'w') as f:
        for item in todo:
            f.write(item)
            f.write('\n')
    print 'done'

def create_if_doesnt_exist(filename):
    if not os.path.isfile(filename):
        with open(filename, 'w') as f:
            pass

def read_from_disk():
    create_if_doesnt_exist(TODO_FILE)
    with open(TODO_FILE, 'r') as f:
        lines = f.readlines()
        return [line.strip() for line in lines]

def exit_cleanly():
    save_to_disk()
    print 'Exiting'
    release_lock()
    os.system("clear")
    exit(0)

# TODO: this should account for all kinds of changes
# not just additions
def undo_last():
    global history
    history.pop()
    todo = history[-1]

def add_item(line):
    global todo
    try:
        item = line[2:].strip()
        todo.append(item)
        print 'Added item:', item
    except IndexError:
        print 'to add a new item, write "+ <item>"'

def delete_item(line):
    global todo
    try:
        idx = int(line.split()[1])
        item = todo[idx]
        del todo[idx]
        print 'Deleted item:', item
    except IndexError:
        print "can't delete that"

def edit_item(line):
    global todo
    try:
        split = line.split(' ', 2)
        idx = int(split[1])
        old_item = todo[idx]
        prefill = old_item
        if len(split) > 2:
            prefill = split[2]
        new_item = input_with_prefill('edit item: ', prefill)
        if new_item is None:
            raise TypeError
        todo[idx] = new_item
        print 'Edited item'
        print 'Before:', old_item
        print 'Now:', new_item
        pop_readline_history()
    except (IndexError, TypeError):
        print "can't edit that"

def copy_to_clipboard(line):
    global todo
    try:
        idx = int(line.split()[1])
        item = todo[idx]
        copy_command = "printf \"" + item + "\" | xsel -ib"
        os.system(copy_command)
        print 'Copied item:', item
    except IndexError:
        print "can't copy that"

def search(line):
    global todo
    try:
        split = line.split()
        query = split[1]
        matches_found = False
        for idx, item in enumerate(todo):
            if query in item:
                matches_found = True
                print 'match:', idx, item
        if not matches_found:
            print 'no matches found'
    except IndexError:
        print "error in search command"

def handle_input(s):
    global todo
    os.system("clear")
    if s[0] in ['?', 'h']:
        show_help()
    elif s[0] == '+':
        add_item(s)
    elif s[0] == '-':
        delete_item(s)
    elif s[0] == 'c':
        copy_to_clipboard(s)
    elif s[0] == 'e':
        edit_item(s)
    elif s[0] == '/':
        search(s)
    elif s[0] == 'u':
        undo_last()
    elif s[0] == 'q':
        exit_cleanly()

def sigint_handler(signal, frame):
    print
    exit_cleanly()

if __name__ == '__main__':
    os.system("clear")
    acquire_lock()

    signal.signal(signal.SIGINT, sigint_handler)
    todo = read_from_disk()

    show_help()
    while True:
        show_todo()
        print
        try:
            inp = raw_input("command: ")
        except EOFError:
            exit_cleanly()
        print
        handle_input(inp)